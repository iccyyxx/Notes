## 继承

### 1、原型链继承

```js
  function Parent1() {
    this.name = 'parent1';
    this.play = [1, 2, 3]
  }
  function Child1() {
    this.type = 'child2';
  }
  Child1.prototype = new Parent1();
  var s1 = new Child1();
  var s2 = new Child2();
  s1.play.push(4);
  console.log(s1.play, s2.play);
```



![image-20220913160048771](D:\Github\Notes\Web\image\image-20220913160048771.png)

综上，可以发现此方法**存在内存空间共享**的问题。

### 2、构造函数继承(借助call/apply函数)

```javascript
 function Parent1(){
    this.name = 'parent1';
  }
  Parent1.prototype.getName = function () {
    return this.name;
  }
  function Child1(){
    Parent1.call(this);
    this.type = 'child1'
  }
  let child = new Child1();
  console.log(child);  // 没问题
  console.log(child.getName());  // 会报错
```

- 解决了内存空间共享问题
- 但是无法继承原型属性或者方法，只能继承父类的实例属性或方法

### 3、组合继承

```javascript
  function Parent3 () {
    this.name = 'parent3';
    this.play = [1, 2, 3];
  }
  Parent3.prototype.getName = function () {
    return this.name;
  }
  function Child3() {
    // 第二次调用 Parent3()
    // 继承属性
    Parent3.call(this);
    this.type = 'child3';
  }
  // 第一次调用 Parent3()
  // 继承方法
  Child3.prototype = new Parent3();
  // !!!手动挂上构造器，指向自己的构造函数？说明作用
  Child3.prototype.constructor = Child3;
  var s3 = new Child3();
  var s4 = new Child3();
  s3.play.push(4);
  console.log(s3.play, s4.play);  // 不互相影响
  console.log(s3.getName()); // 正常输出'parent3'
  console.log(s4.getName()); // 正常输出'parent3'
```

- 解决了原型继承和构造函数继承存在的问题
- Parent3构造了两次，开销增多

### 4、原型式继承

通过 `Object.create`实现

```js
 let parent4 = {
    name: "parent4",
    friends: ["p1", "p2", "p3"],
    getName: function() {
      return this.name;
    }
  };

  let person4 = Object.create(parent4);
  person4.name = "tom";
  person4.friends.push("jerry");


  let person5 = Object.create(parent4);
  person5.friends.push("lucy");


  console.log(person4.name);
  console.log(person4.name === person4.getName());
  console.log(person5.name);
  console.log(person4.friends);
  console.log(person5.friends);
```

- 存在引用类型内存共享的问题

### 5、寄生式继承

```javascript
   let parent5 = {
    name: "parent5",
    friends: ["p1", "p2", "p3"],
    getName: function() {
      return this.name;
    }
  };

  function clone(original) {
    let clone = Object.create(original);
    clone.getFriends = function() {
      return this.friends;
    };
    return clone;
  }
  let person5 = clone(parent5);
  console.log(person5.getName());
  console.log(person5.getFriends());
```

- 相比于原型式继承，此方法可以添加更多的方法，可扩展性更佳，但是原型式存在的问题它也存在(内存共享)

### 6、寄生组合式继承

```javascript
function clone (parent, child) {
	// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程
    child.prototype = Object.create(parent.prototype);
    child.prototype.constructor = child;
  }
  function Parent6() {
    this.name = 'parent6';
    this.play = [1, 2, 3];
  }
   Parent6.prototype.getName = function () {
    return this.name;
  }
  function Child6() {
    Parent6.call(this);
    this.friends = 'child5';
  }
  clone(Parent6, Child6);
  Child6.prototype.getFriends = function () {
    return this.friends;
  }
  let person6 = new Child6();
  console.log(person6);
  console.log(person6.getName());
  console.log(person6.getFriends());
```

### ES6 的 extends 关键字实现逻辑

源码

```js
function _possibleConstructorReturn (self, call) { 
        // ...
        return call && (typeof call === 'object' || typeof call === 'function') ? call : self; 
}
function _inherits (subClass, superClass) { 
    // 这里可以看到
    subClass.prototype = Object.create(superClass && superClass.prototype, { 
        constructor: { 
            value: subClass, 
            enumerable: false, 
            writable: true, 
            configurable: true 
        } 
    }); 
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; 
}

var Parent = function Parent () {
    // 验证是否是 Parent 构造出来的 this
    classCallCheck(this, Parent);
};
var Child = (function (Parent) {
    _inherits(Child, _Parent);
    function Child () {
        _classCallCheck(this, Child);
        return _possibleConstructorReturn(this, (Child.__proto || Object.getPrototypeOf(Child)).apply(this, arguments));
}
    return Child;
}(Parent));
```

### 总结

![image-20220913165205962](D:\Github\Notes\Web\image\image-20220913165205962.png)