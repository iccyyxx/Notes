## 内存管理与垃圾回收

意义：对于日常开发中对高性能 JavaScript 的编写以及排查代码性能问题有着很好的帮助

内容：JS 引擎底层的垃圾回收机制

## 目录

<a href = "#manage">JavaScript 的内存管理</a>

<a href = "#garbage"> Chrome 内存回收机制</a>

​		<a href="#new">新生代内存回收</a>

​		<a href="#promote">对象晋升</a>

​		<a href="#old">老生代内存回收</a>

<a href = "#improve" >内存泄漏与优化</a>

<h2 id="manage">JavaScript 的内存管理</h2>

- 内存使用过程大致分为一下三个步骤：

  1. 分配系统内存空间
  2. 对使用到的内存空间进行读写等操作
  3. 不用的时候释放内存

- JavaScript 会为变量自动分配内存，不再使用时进行垃圾回收处理。

  1. 对于基本类型分配栈内存，内存空间固定，直接通过值访问。
  2. 引用类型分配堆内存，内存空间不固定，通过引用访问(地址)。

  由于堆内存大小不固定，所以需要 JavaScript 的引擎通过垃圾回收机制处理。而栈内存可以操作系统直接处理。

<h2 id="garbage">Chrome 内存回收机制</h2>

Chrome 的 JavaScript 引擎 V8 将内存分为**新生代**和**老生代**两种回收机制。

Scavenge 算法比较适合内存较小的情况处理；而对于老生代内存较大、变量较多的时候，还是需要采用“标记-清除”结合“标记-整理”这样的方式处理内存问题，并尽量避免内存碎片的产生。

<h3 id="new">新生代内存回收</h3>

- 64位操作系统的为 32 MB，32位操作系统的为 16 MB

- 采用 `Scavenge` 算法 进行垃圾回收，以空间换时间。在`Scavenge`算法的具体实现中，主要采用了`Cheney`算法。

  1. 当程序主线程在执行第一个任务时，系统将分配给新生代的内存空间分为两部分,如下图
     <img src="D:\Github\Notes\Web\image\image-20220905181334414.png" alt="image-20220905181334414" style="zoom: 33%;" />

     From 为正在使用的内存空间，To 为目前闲置的内存空间。

  2. 当浏览器开始垃圾回收时，会检查 From 中的对象。
     若对象是存活的(不被清理)，则将其复制到 To ，将不存在于 From
     若对象不是存活(要被清理)，则直接进行系统回收

  3. 当 From 为空，程序主线程在执行第二个任务，有新生代的对象产生时，则 From 和 To 对调过来。即原来的 From 变为后来的 To，后来的 To 变为原来的 From。

  4. 依次循环下去

<h3 id="promote">对象晋升</h3>

新生代中的变量如果经过回收之后依然一直存在，那么就会被放入到老生代内存中。时间长了之后通过几个原因的判断，我们就会把这些变量进行 "晋升"，只要是已经经历过一次 Scavenge 算法回收的，就可以晋升为老生代内存的对象。

<h3 id="old">老生代内存回收</h3>

采用了 Mark-Sweep（标记清除） 和 Mark-Compact（标记整理）的策略

<h4 id="old-one">Mark-Sweep（标记清除）</h4>

1. 在代码执行前遍历堆上的所有对象，将其打上标记。
2. 在代码执行结束之后，将使用过的变量取消标记。
3. 在清除阶段将有标记的进行清除，从而释放内存空间

但是会出现内存碎片的问题，之后对存储造成影响。

<h4 id="old-two">Mark-Compact（标记整理）</h4>

为了解决浏览器中的内存碎片问题，基于标记清除之上提出了标记整理策略。

与标记清除相比，标记整理在处理过程中将所有的活动对象往一端靠拢，整体移动完成后，直接清理掉边界外的内存。其操作效果如下图所示。

<img src="D:\Github\Notes\Web\image\image-20220905204157903.png" alt="image-20220905204157903" style="zoom:50%;" />

<h3 id="improve">内存泄漏与优化</h3>

- **内存泄漏**
  是指 JavaScript 中，已经分配堆内存地址的对象由于长时间未释放或者无法释放，造成了长期占用内存，使内存浪费，最终会导致运行的应用响应速度变慢以及最终崩溃的情况。

- **内存泄漏的场景**，这些现象会在开发或者使用中造成内存泄漏，以至于你的浏览器卡顿、不响应、页面打不开等问题产生。

  1. 过多的**缓存**未释放；
  2. **闭包**太多未释放；
  3. **定时器**或者**回调**太多未释放；
  4. 太多**无效的 DOM** 未释放；
  5. **全局变量太多**未被发现。

- 优化方案：

  1. **减少不必要的全局变量，使用严格模式避免意外创建全局变量**。

  2. **在你使用完数据后，及时解除引用**（闭包中的变量，DOM 引用，定时器、监听器清除）

  3. **组织好代码逻辑，避免死循环等造成浏览器卡顿、崩溃的问题**。

     例如，对于一些比较占用内存的对象提供手工释放内存的方法，请看下面代码：

     ```javascript
     var leakArray = [];
     exports.clear = function () {
         leakArray = [];
     }
     ```

     比如这段代码提供了清空该数组内容的方法，使用完成之后可以根据合适业务时机进行操作释放。这样就能较好地避免对象数据量太大造成的内存溢出的问题。

  4. 想更好地去排查以及提前避免问题的发生，最好的解决方式是通过熟练使用 Chrome 的内存剖析工具，多分析多定位 Chrome 帮你分析保留的内存快照，来查看持续占用大量内存的对象。

## 参考文献

[一文搞懂V8引擎的垃圾回收](https://juejin.cn/post/6844904016325902344)

