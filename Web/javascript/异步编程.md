## 异步编程

JS 异步编程的方式有：

- 回调函数
- 事件监听
- Promise
- Generator
- async/await

## 目录

<a href = "sync">同步与异步</a>

<a href = "#way">JS 异步编程的方式</a>

​        <a href = "#promise">Promise</a>

​        <a href = "#Generator">Generator</a>

       [async/await](#asyne)

<h2 id="sync">同步与异步</h2>

- 同步：
  在此段代码执行完未返回结果之前，会阻塞之后的代码执行

- 异步：
  
  当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果。而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。
  异步调用发出后，不会影响阻塞后面的代码执行。

- 为什么需要异步？
  
  因为 JavaScript 是单线程的，一段代码如果同步执行的话结果如果没法及时返回将会阻塞后面的代码的执行，而使用异步则不会阻塞。

- 回调实现异步编程的场景，可能出现回调地狱，比如：
  
  1. ajax 请求的回调；
  2. 定时器中的回调；
  3. 事件回调；

<h2 id="way">JS 异步编程的方式</h2>

- 回调函数
  早些年 JS 异步编程的方式
- Promise
  ES6 新增，解决回调地狱问题
- Generator
  和 yield 配合使用，返回迭代器
- async/await

<h3 id="promise">Promise</h3>

Promise 是一个对象，从它可以获取异步操作的消息。用于表示一个异步操作的最终完成（或失败）及其结果值。

#### Promise 的链式调用

```js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('foo');
  }, 300);
});

myPromise
  .then(handleResolvedA, handleRejectedA)
  .then(handleResolvedB, handleRejectedB)
  .then(handleResolvedC, handleRejectedC)
  .catch(handleRejectedAny);;
```

#### Promise 执行过程的状态

- *待定（pending）*：初始状态，既没有被兑现，也没有被拒绝。
- *已兑现（fulfilled）*：意味着操作成功完成。
- *已拒绝（rejected）*：意味着操作失败。

![img](D:\Github\Notes\Web\image\promises.png)

#### Promise 如何解决回调地狱

回调地狱有两个主要的问题：

1. 多层嵌套的问题；
2. 每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。

Promise 利用了三大技术手段来解决回调地狱：回调函数延迟绑定、返回值穿透、错误冒泡。

#### Promise 的静态方法

![image-20220906153620109](D:\Github\Notes\Web\image\image-20220906153620109.png)

- **`Promise.all（iterable）`**
  
  在 ES6 中可以将多个 Promise.all 异步请求并行操作，返回结果一般有下面两种情况。
  
  1. 当所有结果成功返回时按照请求顺序**返回成功**。
  2. 当其中有一个失败方法时，则进入**失败方法**。

- **`Promise.allSettled(iterable)`**
  
  等到所有 promise 都已敲定（每个 promise 都已兑现或已拒绝）。
  
  返回一个 promise，该 promise 在所有 promise 都敲定后完成，并兑现一个对象数组，其中的对象对应**每个 promise 的结果。**

- **[`Promise.any(iterable)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any)**
  
  接收一个 promise 对象的集合，当其中的任意一个 promise 成功，就**返回成功的 promise 的值。**
  
  如果传入了一个空的可迭代对象，那么就会返回一个已经被拒的 `promise`
  
  如果可迭代对象中的所有 `promise` 都被拒绝了，那么这个处于等待状态的 `promise` 就会异步地切换至被拒状态。

- [`Promise.race(iterable)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)
  
  等到任意一个 promise 的状态变为已敲定。
  
  当 iterable 参数里的任意一个子 promise 成功或失败后，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应处理函数，**并返回该 promise 对象**。

<h3 id="#Generator">Generator--ES7</h3>

Generator 是一个带星号的“函数”，可以配合 yield 关键字来暂停或者执行函数。

Generator 中配合使用 yield 关键词可以控制函数执行的顺序，每当执行一次 next 方法，Generator 函数会执行到下一个存在 yield 关键词的位置。

```js
function* gen1() {
    yield 1;
    yield* gen2();
    yield 4;
}
function* gen2() {
    yield 2;
    yield 3;
}
var g = gen1();
console.log(g.next())// { value: 1, done: false }
console.log(g.next())// { value: 2, done: false }
console.log(g.next())// { value: 3, done: false }
console.log(g.next())// { value: 4, done: false }
console.log(g.next())// {value: undefined, done: true}
```

Generator 的执行有这几个关键点。

1. 调用 gen() 后，程序会阻塞住，不会执行任何语句。
2. 调用 g.next() 后，程序继续执行，直到遇到 yield 关键词时执行暂停。
3. 一直执行 next 方法，最后返回一个对象，其存在两个属性：value 和 done。

#### Generator 和 thunk 结合

#### Generator 和 Promise 结合

#### co 函数库

co 函数库是著名程序员 TJ 发布的一个小工具，用于处理 Generator 函数的自动执行。核心原理其实就是上面讲的通过和 thunk 函数以及 Promise 对象进行配合，包装成一个库。

```java
const co = require('co');
let g = gen();
co(g).then(res =>{
  console.log(res);
})
```

为什么 co 函数库可以自动执行 Generator 函数，它的处理原理是什么呢？

1. 因为 Generator 函数就是一个异步操作的容器，它需要一种自动执行机制，co 函数接受 Generator 函数作为参数，并最后返回一个 Promise 对象。
2. 在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数；如果不是就返回，并将 Promise 对象的状态改为 resolved。
3. co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulfilled 函数。这主要是为了能够捕捉抛出的错误。
4. 关键的是 next 函数，它会反复调用自身。

<h3 id="#async">async/await</h3>

async 函数对 Generator 函数的改进，主要体现在以下三点。

1. 内置执行器：Generator 函数的执行必须靠执行器，因为不能一次性执行完成，所以之后才有了开源的 co 函数库。但是，async 函数和正常的函数一样执行，也不用 co 函数库，也不用使用 next 方法，而 async 函数自带执行器，会自动执行。
2. 适用性更好：co 函数库有条件约束，yield 命令后面只能是 Thunk 函数或 Promise 对象，但是 async 函数的 await 关键词后面，可以不受约束。
3. 可读性更好：async 和 await，比起使用 * 号和 yield，语义更清晰明了。

![image-20220906164724899](D:\Github\Notes\Web\image\image-20220906164724899.png)