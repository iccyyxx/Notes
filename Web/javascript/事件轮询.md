## 事件轮询

### 浏览器的 Eventloop

#### JS 引擎流程

**JS 引擎的全局流程图**
<img src="D:\Github\Notes\Web\image\image-20220906191826610.png" alt="image-20220906191826610" style="zoom:150%;" />

**1. 调用堆栈（call stack）负责跟踪所有要执行的代码**
<img src="D:\Github\Notes\Web\image\image-20220906191540964.png" alt="image-20220906191540964" style="zoom:50%;" />

**2. 事件队列（event queue）负责将新的 function 发送到队列中进行处理**

<img src="D:\Github\Notes\Web\image\image-20220906191619860.png" alt="image-20220906191619860" style="zoom:50%;" />

**3.每当调用事件队列（event queue）中的异步函数时，都会将其发送到浏览器 API**。

根据从调用堆栈收到的命令，API 开始自己的单线程操作。

**4.JavaScript 语言本身是单线程的，而浏览器 API 充当单独的线程**。

事件循环（Eventloop）促进了这一过程，它会不断检查调用堆栈是否为空。如果为空，则从事件队列中添加新的函数进入调用栈（call stack）；如果不为空，则处理当前函数的调用。

#### Eventloop 的内部

通过两个任务队列实现异步任务。宏任务放到宏任务队列（macrotask queue），微任务，放到微任务队列（microtask queue）中。

**宏任务**

```js
script(整体代码)
setTimeout
setInterval
setImmediate
I/O
UI rendering
event listner
```

**微任务**

```java
process.nextTick
Promises
Object.observe
MutationObserver
```

**处理顺序**：**一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务**。

1. JavaScript 引擎首先从宏任务队列（macrotask queue）中取出第一个任务；
2. 执行完毕后，再将微任务（microtask queue）中的所有任务取出，按照顺序分别全部执行，如果在这一步过程中产生新的微任务，也需要执行；
3. 然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。

### Node.js 的 Eventloop

**下面的图表展示了事件循环操作顺序的简化概览。**

<img src="D:\Github\Notes\Web\image\image-20220906214541153.png" alt="image-20220906214541153" style="zoom:50%;" />

对应 6 个阶段，每个阶段都用一个队列来执行回调。

- timers **定时器**：本阶段执行已经被 `setTimeout()` 和 `setInterval()` 的调度回调函数。
- pending callbacks **待定回调**：执行延迟到下一个循环迭代的 I/O 回调。
- idle, prepare 仅系统内部使用。
- poll **轮询**：检索新的 I/O 事件;执行与 I/O 相关的回调，*控制何时定时器执行。*
  <img src="D:\Github\Notes\Web\image\image-20220906215510522.png" alt="image-20220906215510522" style="zoom:150%;" />
- check **检测**：`setImmediate()` 回调函数在这里执行。
- close callbacks **关闭的回调函数**：一些关闭的回调函数，如：`socket.on('close', ...)`。

在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则完全关闭。

Node.js 和浏览器端宏任务队列的**不同点**是，浏览器端任务队列每轮事件循环仅出队一个回调函数接着去执行微任务队列；而 Node.js 端只要轮到执行某个宏任务队列，则会执行完队列中所有的当前任务，但是当前轮次新添加到队尾的任务则会等到下一轮次才会执行。

### EventLoop 对渲染的影响

## 参考文献

[Node.js 事件循环，定时器和 `process.nextTick()`]([Node.js 事件循环，定时器和 process.nextTick() | Node.js (nodejs.org)](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/))