# 拷贝

## 浅拷贝

自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象。（内存共享）

### Object.assign--浅拷贝

object.assign 是 ES6 中 object 的一个方法，该方法可以用于 JS 对象的合并等多个用途，其中一个用途就是可以进行浅拷贝。

object.assign 的语法为：`Object.assign(target, ...sources)`

- 不拷贝对象的继承属性(对象从原型对象继承的属性)、不可枚举属性
- 可以拷贝 Symbol 类型的属性

### 扩展运算符方式--浅拷贝

我们也可以利用 JS 的扩展运算符，在构造对象的同时完成浅拷贝的功能。

> 扩展运算符的语法为：let cloneObj = { ...obj };

### concat 拷贝数组--浅拷贝

连接一个含有引用类型的数组时，需要注意修改原数组中的元素的属性，因为它会影响拷贝之后连接的数组。

### slice 拷贝数组--浅拷贝

仅仅针对数组类型，slice 方法会返回一个新的数组对象，这一对象由该方法的前两个参数来决定原数组截取的开始和结束时间，是不会影响和改变原始数组的。

### 手写浅拷贝

- 基础类型为值传递，直接复制
- 引用类型为地址传递

```js
const shallowClone = (target) => {
  if (typeof target === 'object' && target !== null) {
    const cloneTarget = Array.isArray(target) ? []: {};
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = target[prop];
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```

## 深拷贝

将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。

### JSON.stringify--深拷贝

把一个对象序列化成为 JSON 的字符串，并将对象里面的内容转换成字符串，最后再用 JSON.parse() 的方法将JSON 字符串生成一个新的对象。

```javascript
let obj1 = { a:1, b:[1,2,3] }
let str = JSON.stringify(obj1)；
let obj2 = JSON.parse(str)；
```

- 若其中存在函数、undefined、symbol 这几种类型，序列化之后键值对消失
- 拷贝 Date 引用类型会变成字符串；
- 无法拷贝不可枚举的属性、对象的原型链
- 拷贝 RegExp 引用类型会变成空对象；
- 对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；
- 无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。

### 手写深拷贝（基础版）

```javascript
function deepClone(obj) { 
  let cloneObj = {}
  for(let key in obj) {                 //遍历
    if(typeof obj[key] ==='object') { 
      cloneObj[key] = deepClone(obj[key])  //是对象就再次调用该函数递归
    } else {
      cloneObj[key] = obj[key]  //基本类型的话直接复制值
    }
  }
  return cloneObj
}
```

- 不能复制不可枚举的属性以及 Symbol 类型；
- 对于 Array、Date、RegExp、Error、Function 这样的引用类型并不能正确地拷贝；
- 对象的属性里面成环，即循环引用没有解决

### 手写深拷贝（改进版）

- 针对不可枚举属性以及Symbol类型可以使用Reflect.ownKeys方法
- 当参数为 Date、RegExp 类型，则直接生成一个新的实例返回；
- 利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链；
- 利用 WeakMap 类型作为 Hash 表，因为 WeakMap 是弱引用类型，可以有效防止内存泄漏，作为检测循环引用很有帮助，如果存在循环，则引用直接返回 WeakMap 存储的值。

```javascript
const isComplexDataType = obj =>
  (typeof obj === 'object' || typeof obj === 'function') && obj !== null
function myDeepCopy(source, hash = WeakMap()) {
  /* 特殊类型处理 */
  if (source.constructor === Date) return new Date(source)
  if (source.constructor === RegExp) return new RegExp(source)
  /* 解决循环引用问题 */
  if (hash.has(source)) return hash.get(source)
  /* 获取对象的所有自身属性的描述符 */
  let allDecs = Object.getOwnPropertyDescriptors(source)
  /* 继承原型链 */
  let target = Object.create(Object.getPrototypeOf(source), allDecs)
  hash.set(source, target)
  for (let key of Reflect.ownKeys(source)) {
    target[key] =
      isComplexDataType(source[key]) && typeof source[key] !== 'function'
        ? myDeepCopy(source[key], hash)
        : source[CryptoKey]
  }
  return target;
}
```

![image-20220913150729974](D:\Github\Notes\Web\image\image-20220913150729974.png)